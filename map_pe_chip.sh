#!/bin/bash

# Copyright 2015 Junko Tsuji

# Modified version of ENCODE 3 ChIP-seq pipeline for paired-end
# reads. Make sure to edit software paths beforehand.

#### Software path
export PATH=$PATH:/home/tsujij/soft/bwa-0.7.12/
export PATH=$PATH:/home/tsujij/soft/samtools-1.0/
export PATH=$PATH:/home/tsujij/soft/bedtools2-2.20.1/bin/
export PATH=$PATH:/home/tsujij/soft/picard-tools-1.130/
PICARD_JAR="/home/tsujij/soft/picard-tools-1.130/picard.jar"

#### Usage
function usage {
cat << EOF
Usage: $0 [options] -t <aln | mem> -g <genome-index> -f <fastq1> -r <fastq2>

Map paired-end histone ChIP-seq reads.

Required arguments:
  -t <aln | mem>     Alignment mode for bwa.
                       - aln: short reads, e.g. 36bp
                       - mem: long reads, e.g. 70bp-1Mbp
  -g <genome-index>  Genome index generated by bwa index.
  -f <fastq1>        FASTQ containing paired-end upstream mates.
  -r <fastq2>        FASTQ containing paired-end downstream mates.

Options:
  -h                 Show this help message and exit.
  -x <exclude-list>  Sequence names that need to be removed for subsequent analysis,
                     e.g. sponges, or virus sequences to sink contaminant reads.
                     Each line should contain a sequence name and a tab,
                     i.e. 'remove_sequence_1\t'
                          'remove_sequence_2\t' ...
  -Q <mapQ-score>    Mapping quality score of bwa (default: mem=20, aln=30).
  -p <cpu-num>       Number of CPUs for mapping (default: 8 cores).
  -o <prefix>        Prefix for output files (default: prefix of <fastq1>).
EOF
}

#### Parameters
NTHREADS=8
unset MAPQ
unset BWA_MODE
unset BWA_INDEX
unset FASTQ_1
unset FASTQ_2
unset OFPREFIX
unset EXCLUDE

#### Read arguments and options
[[ $# -eq 0 ]] && usage && exit 1;
while getopts "ht:g:f:r:x:p:Q:o:" OPT
do
  case ${OPT} in
    "t") BWA_MODE=${OPTARG} ;;
    "g") BWA_INDEX=${OPTARG};;
    "f") FASTQ_1=${OPTARG}  ;;
    "r") FASTQ_2=${OPTARG}  ;;
    "x") EXCLUDE=${OPTARG}  ;;
    "Q") MAPQ=${OPTARG}     ;;
    "p") NTHREADS=${OPTARG} ;;
    "o") OFPREFIX=${OPTARG} ;;
    "h") usage && exit 1    ;;
     * ) usage && exit 1    ;;
  esac
done
[[ $# -lt 8 ]] && echo "$0: need more arguments" && exit 1;

#### Check arguments
if [ "${BWA_MODE}" != "mem" ] && [ "${BWA_MODE}" != "aln" ]
  then echo "$0: input 'aln' or 'mem'" && exit 1; fi
if [ -z "${BWA_INDEX}" ]
  then echo "$0: input bwa genome index" && exit 1; fi
if [ $( ls -1 ${BWA_INDEX}.* | wc -l ) -le 4 ]
  then echo "$0: can't interpret bwa genome index" && exit 1; fi
if [ ! -f "${FASTQ_1}" ] || [ ! -f "${FASTQ_2}" ]
  then echo "$0: can't read FASTQ" && exit 1; fi
if [ $( echo ${NTHREADS} | sed 's/^[+0-9][0-9]*//' | wc -c ) -ne 1 ]
  then echo "$0: can't interpret -p ${NTHREADS}" && exit 1; fi
if [ $( echo ${MAPQ} | sed 's/^[+0-9][0-9]*//' | wc -c ) -ne 1 ]
  then echo "$0: can't interpret -Q ${MAPQ}" && exit 1; fi
if [ -z "${MAPQ}" ]
  then
    if [ "${BWA_MODE}" == "mem" ]; then MAPQ=20; fi
    if [ "${BWA_MODE}" == "aln" ]; then MAPQ=30; fi
  fi
if [ ! -z "${EXCLUDE}" ]
  then if [ ! -f "${EXCLUDE}" ]
    then echo "$0: can't read ${EXCLUDE}" && exit 1; fi
  fi
if [ -z "${OFPREFIX}" ]
  then OFPREFIX=`basename ${FASTQ_1} | awk -F ".fq" '{print $1}' | awk -F ".fastq" '{print $1}'`; fi

#### Map reads with BWA
RAW_SAM_FILE="${OFPREFIX}.raw.sam.gz"
if [ "${BWA_MODE}" == "mem" ]
then
  bwa mem -M -t ${NTHREADS} ${BWA_INDEX} ${FASTQ_1} ${FASTQ_2} | gzip -c > ${RAW_SAM_FILE}
else
  SAI_1="${OFPREFIX}_1.sai"
  SAI_2="${OFPREFIX}_2.sai"
  bwa aln -q 5 -l 32 -k 2 -t ${NTHREADS} ${BWA_INDEX} ${FASTQ_1} > ${SAI_1}
  bwa aln -q 5 -l 32 -k 2 -t ${NTHREADS} ${BWA_INDEX} ${FASTQ_2} > ${SAI_2}
  bwa sampe ${BWA_INDEX} ${SAI_1} ${SAI_2} ${FASTQ_1} ${FASTQ_2} | gzip -c > ${RAW_SAM_FILE}
  rm ${SAI_1} ${SAI_2}
fi

#### Find reads that have bad CIGAR strings (the ones including gaps)
BADCIGAR_FILE="${OFPREFIX}.badcigar"
zcat ${RAW_SAM_FILE} | \
awk 'BEGIN{ FS = "\t"; OFS = "\t" }
     ! /^@/ && $6!="*" { cigar = $6;
     gsub("[0-9]+D", "", cigar);
     n = split(cigar, vals, "[A-Z]");
     s = 0; for (i=1; i<=n; i++) s = s + vals[i];
     seqlen = length($10);
     if (s != seqlen) print $1"\t"; }' | sort | uniq > ${BADCIGAR_FILE}

#### Remove bad CIGAR read pairs
RAW_BAM_PREFIX="${OFPREFIX}.raw.srt"
RAW_BAM_FILE="${RAW_BAM_PREFIX}.bam"
RAW_BAM_FILE_MAPSTATS="${RAW_BAM_PREFIX}.flagstat.qc"
if [[ $(cat ${BADCIGAR_FILE} | wc -l) -gt 0 ]]
then
    zcat ${RAW_SAM_FILE} | grep -v -F -f ${BADCIGAR_FILE} | \
    samtools view -Su - | samtools sort - ${RAW_BAM_PREFIX}
else
    samtools view -Su ${RAW_SAM_FILE} | samtools sort - ${RAW_BAM_PREFIX}
fi
samtools flagstat ${RAW_BAM_FILE} > ${RAW_BAM_FILE_MAPSTATS}
rm ${BADCIGAR_FILE} ${RAW_SAM_FILE}

#### Filter unmapped, mate unmapped, not primary alignment, and low quality reads
FILT_BAM_PREFIX="${OFPREFIX}.filt.srt"
FILT_BAM_FILE="${FILT_BAM_PREFIX}.bam"
TMP_FILT_BAM_PREFIX="${FILT_BAM_PREFIX}.tmp.nmsrt"
TMP_FILT_BAM_FILE="${TMP_FILT_BAM_PREFIX}.bam"
TMP_FILT_BAM_FILE_CLEAN="${TMP_FILT_BAM_PREFIX}.clean.bam"
samtools view -F 1804 -f 2 -q ${MAPQ} -u ${RAW_BAM_FILE} | \
samtools sort -n - ${TMP_FILT_BAM_PREFIX}

#### Filter orphan reads (pair was removed) and read pairs mapping to different chromosomes
samtools fixmate -r ${TMP_FILT_BAM_FILE} ${TMP_FILT_BAM_FILE_CLEAN}
samtools view -F 1804 -f 2 -u ${TMP_FILT_BAM_FILE_CLEAN} | \
samtools sort - ${FILT_BAM_PREFIX}
rm ${TMP_FILT_BAM_FILE} ${TMP_FILT_BAM_FILE_CLEAN}

#### Mark duplicates with picard
TMP_FILT_BAM_FILE="${FILT_BAM_PREFIX}.dupmark.bam"
DUP_FILE_QC="${FILT_BAM_PREFIX}.dup.qc"
java -Xmx4G -jar ${PICARD_JAR} MarkDuplicates INPUT=${FILT_BAM_FILE} OUTPUT=${TMP_FILT_BAM_FILE} \
METRICS_FILE=${DUP_FILE_QC} VALIDATION_STRINGENCY=LENIENT ASSUME_SORTED=true REMOVE_DUPLICATES=false
mv ${TMP_FILT_BAM_FILE} ${FILT_BAM_FILE}
rm ${RAW_BAM_FILE}

#### Remove duplicates and sponges, and create final name sorted BAM
FINAL_BAM_PREFIX="${OFPREFIX}.filt.srt.nodup"
FINAL_BAM_FILE="${FINAL_BAM_PREFIX}.bam"
FINAL_BAM_INDEX_FILE="${FINAL_BAM_PREFIX}.bai"
FINAL_BAM_FILE_MAPSTATS="${FINAL_BAM_PREFIX}.flagstat.qc"
FINAL_NMSRT_BAM_PREFIX="${OFPREFIX}.filt.nmsrt.nodup"
FINAL_NMSRT_BAM_FILE="${FINAL_NMSRT_BAM_PREFIX}.bam"
if [ ! -z "${EXCLUDE}" ]
then
    samtools view -F 1804 -f 2 -h ${FILT_BAM_FILE} | \
    grep -v -F -f ${EXCLUDE} - | samtools view -Su - > ${FINAL_BAM_FILE}
else
    samtools view -F 1804 -f 2 -b ${FILT_BAM_FILE} > ${FINAL_BAM_FILE}
fi
samtools sort -n ${FINAL_BAM_FILE} ${FINAL_NMSRT_BAM_PREFIX}

#### Index final sorted BAM
samtools index ${FINAL_BAM_FILE}
mv ${FINAL_BAM_FILE}.bai ${FINAL_BAM_INDEX_FILE}
samtools flagstat ${FINAL_BAM_FILE} > ${FINAL_BAM_FILE_MAPSTATS}

#### Compute library complexity
# Tab-delimited output:
# [1] TotalReadPairs
# [2] DistinctReadPairs
# [3] OneReadPairs
# [4] TwoReadPairs
# [5] NRF=Distinct/Total
# [6] PBC1=OnePair/Distinct
# [7] PBC2=OnePair/TwoPair
PBC_FILE_QC="${FINAL_BAM_PREFIX}.pbc.qc"
samtools sort -n ${FILT_BAM_FILE} ${FILT_BAM_FILE}_tmp
mv ${FILT_BAM_FILE}_tmp.bam ${FILT_BAM_FILE}
echo 1 | awk '{print "#Total\tDistinct\tOne\tTwo\tNRF\tPBC1\tPBC2"}' > ${PBC_FILE_QC}
bedtools bamtobed -bedpe -i ${FILT_BAM_FILE} | \
awk 'BEGIN{OFS="\t"}{print $1,$2,$4,$6,$9,$10}' | grep -v 'chrM' | sort | uniq -c | \
awk 'BEGIN{mt=0;m0=0;m1=0;m2=0}
     ($1==1){m1=m1+1} ($1==2){m2=m2+1} {m0=m0+1} {mt=mt+$1}
     END{printf "%d\t%d\t%d\t%d\t%f\t%f\t%f\n",mt,m0,m1,m2,m0/mt,m1/m0,m1/m2}' >> ${PBC_FILE_QC}
rm ${FILT_BAM_FILE}

#### Convert final name sorted BAM to BEDPE
FINAL_BEDPE_FILE="${FINAL_NMSRT_BAM_PREFIX}.bedpe.gz"
bedtools bamtobed -bedpe -mate1 -i ${FINAL_NMSRT_BAM_FILE} | gzip -c > ${FINAL_BEDPE_FILE}
rm ${FINAL_NMSRT_BAM_FILE}

#### Clean up
mv ${FINAL_BEDPE_FILE} "${OFPREFIX}.bedpe.gz"
mv ${FINAL_BAM_FILE} "${OFPREFIX}.bam"
mv ${FINAL_BAM_INDEX_FILE} "${OFPREFIX}.bai"
mv ${PBC_FILE_QC} "${OFPREFIX}".QC.pbc
mv ${DUP_FILE_QC} "${OFPREFIX}".QC.markdups
mv ${RAW_BAM_FILE_MAPSTATS} "${OFPREFIX}".QC.raw.mapstats
mv ${FINAL_BAM_FILE_MAPSTATS} "${OFPREFIX}".QC.final.mapstats
